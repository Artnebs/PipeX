/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/07 15:23:54 by anebbou           #+#    #+#             */
/*   Updated: 2025/01/18 14:22:15 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

/**
 * execute_pipeline - Executes two commands connected via a pipe.
 * @cmd1: First command with its arguments.
 * @cmd2: Second command with its arguments.
 * @envp: Array of environment variables.
 *
 * Creates a pipe to connect the output of the first command to the input
 * of the second command. Handles child processes for execution.
 */
void execute_pipeline(char **cmd1, char **cmd2, char **envp)
{
	int pipe_fd[2];
	pid_t pid1, pid2;

	if (pipe(pipe_fd) < 0)
	{
		perror("Pipe creation failed");
		exit(EXIT_FAILURE);
	}

	pid1 = fork();
	if (pid1 < 0)
	{
		perror("Fork failed");
		exit(EXIT_FAILURE);
	}
	if (pid1 == 0)
	{
		// First child: Executes cmd1
		dup2(pipe_fd[1], STDOUT_FILENO); // Redirect stdout to pipe write-end
		close(pipe_fd[0]);				 // Close unused read-end
		close(pipe_fd[1]);				 // Close write-end after duplication
		execute_command(cmd1, envp);
	}

	pid2 = fork();
	if (pid2 < 0)
	{
		perror("Fork failed");
		exit(EXIT_FAILURE);
	}
	if (pid2 == 0)
	{
		// Second child: Executes cmd2
		dup2(pipe_fd[0], STDIN_FILENO); // Redirect stdin to pipe read-end
		close(pipe_fd[1]);				// Close unused write-end
		close(pipe_fd[0]);				// Close read-end after duplication
		execute_command(cmd2, envp);
	}

	// Parent process: Close all pipe ends and wait for children
	close(pipe_fd[0]);
	close(pipe_fd[1]);
	waitpid(pid1, NULL, 0);
	waitpid(pid2, NULL, 0);
}

/**
 * execute_command - Executes a single command using execve.
 * @cmd: Command with its arguments.
 * @envp: Array of environment variables.
 *
 * Uses execve to replace the current process image with the new program.
 * Exits the program on failure.
 */
void execute_command(char **cmd, char **envp)
{
	char *cmd_path = find_command_path(cmd[0], envp);
	if (!cmd_path)
	{
		ft_printf("Execution failed: Command not found: %s\n", cmd[0]);
		ft_free_split(cmd);
		exit(EXIT_FAILURE);
	}
	if (execve(cmd_path, cmd, envp) < 0)
	{
		perror("Execution failed");
		ft_free_split(cmd);
		free(cmd_path);
		exit(EXIT_FAILURE);
	}
	free(cmd_path);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   here_doc.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 18:12:36 by anebbou           #+#    #+#             */
/*   Updated: 2025/01/18 14:11:26 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

/**
 * handle_here_doc - Handles the here_doc feature.
 * @limiter: String that marks the end of user input.
 * @cmds: Array of command strings.
 * @cmd_count: Number of commands.
 * @file: Output file to append the result.
 * @envp: Array of environment variables.
 *
 * Reads input from the user until the limiter is encountered, then executes
 * the provided commands, passing the input via pipes.
 */
void handle_here_doc(char *limiter, char **cmds, int cmd_count, char *file, char **envp)
{
	int pipefd[2];
	pid_t pid;
	char *line;

	if (pipe(pipefd) < 0)
	{
		perror("Pipe creation failed");
		exit(EXIT_FAILURE);
	}

	pid = fork();
	if (pid < 0)
	{
		perror("Fork failed");
		exit(EXIT_FAILURE);
	}

	if (pid == 0)
	{
		// Child process: Write user input to pipe until LIMITER
		close(pipefd[0]); // Close read-end
		ft_printf("heredoc> ");
		while ((line = get_next_line(STDIN_FILENO)))
		{
			if (ft_strncmp(line, limiter, ft_strlen(limiter)) == 0 && line[ft_strlen(limiter)] == '\n')
				break; // Stop on LIMITER
			write(pipefd[1], line, ft_strlen(line));
			ft_printf("heredoc> ");
			free(line);
		}
		free(line);
		close(pipefd[1]);
		exit(EXIT_SUCCESS);
	}

	// Parent process: Close write-end and pass heredoc input to commands
	close(pipefd[1]);
	if (cmd_count == 2)
	{
		// Last command appends output to file
		int fd_out = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
		if (fd_out < 0)
		{
			perror("Error opening output file");
			exit(EXIT_FAILURE);
		}
		dup2(pipefd[0], STDIN_FILENO);
		dup2(fd_out, STDOUT_FILENO);
		close(fd_out);
		char **cmd_args = parse_command(cmds[1]);
		execute_command(cmd_args, envp);
		ft_free_split(cmd_args); // Free allocated memory
	}
	else
	{
		execute_multiple_pipes(NULL, file, cmds, cmd_count, envp);
	}
	close(pipefd[0]);
	waitpid(pid, NULL, 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 17:58:45 by anebbou           #+#    #+#             */
/*   Updated: 2025/01/18 14:11:49 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

/**
 * validate_environment - Ensures the environment variables are valid.
 * @envp: Environment variables array.
 *
 * Checks if the `PATH` variable exists in the environment.
 * Exits the program with an error message if the environment is invalid.
 */
void validate_environment(char **envp)
{
	int i = 0;

	if (!envp || !*envp)
	{
		ft_printf("Error: Missing environment variables.\n");
		exit(EXIT_FAILURE);
	}

	while (envp[i])
	{
		if (ft_strncmp(envp[i], "PATH=", 5) == 0)
			return; // PATH variable found
		i++;
	}

	ft_printf("Error: PATH variable is missing in the environment.\n");
	exit(EXIT_FAILURE);
}

/**
 * main - Entry point for the pipex program.
 * @argc: Argument count.
 * @argv: Argument vector.
 * @envp: Environment variables.
 *
 * Handles both the mandatory and bonus parts of the project. Supports two
 * commands with a single pipe and extended functionality for here_doc and
 * multiple pipes.
 *
 * Returns:
 *   EXIT_SUCCESS on success, or exits with failure status on error.
 */
int main(int argc, char **argv, char **envp)
{
	// Validate environment variables
	validate_environment(envp);

	if (argc < 5)
	{
		ft_printf("Usage: ./pipex file1 cmd1 cmd2 [cmd3 ...] file2\n");
		return (EXIT_FAILURE);
	}

	if (ft_strncmp(argv[1], "here_doc", ft_strlen("here_doc")) == 0)
	{
		if (argc < 6)
		{
			ft_printf("Usage for here_doc: ./pipex here_doc LIMITER cmd1 ... cmdn file\n");
			return (EXIT_FAILURE);
		}
		handle_here_doc(argv[2], &argv[3], argc - 4, argv[argc - 1], envp);
	}
	else
	{
		validate_files(argv[1], argv[argc - 1]);
		if (argc == 5)
		{
			setup_redirection(argv[1], argv[argc - 1]);
			char **cmd1 = parse_command(argv[2]);
			char **cmd2 = parse_command(argv[3]);
			execute_pipeline(cmd1, cmd2, envp);
			ft_free_split(cmd1);
			ft_free_split(cmd2);
		}
		else
		{
			execute_multiple_pipes(argv[1], argv[argc - 1], &argv[2], argc - 3, envp);
		}
	}
	return (EXIT_SUCCESS);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   multiple_pipes.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 18:10:20 by anebbou           #+#    #+#             */
/*   Updated: 2025/01/18 14:10:00 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

/**
 * execute_multiple_pipes - Executes multiple commands connected via pipes.
 * @file1: Input file path (not used in this implementation).
 * @file2: Output file path (not used in this implementation).
 * @cmds: Array of command strings.
 * @cmd_count: Number of commands.
 * @envp: Array of environment variables.
 *
 * Sets up dynamic pipes for the commands and uses fork to execute each
 * command in a separate child process. Cleans up resources after execution.
 */
void execute_multiple_pipes(char *file1, char *file2, char **cmds, int cmd_count, char **envp)
{
	(void)file1;
	(void)file2;

	int pipes[cmd_count - 1][2];
	pid_t pids[cmd_count];

	for (int i = 0; i < cmd_count - 1; i++)
		if (pipe(pipes[i]) < 0)
		{
			perror("Pipe creation failed");
			exit(EXIT_FAILURE);
		}

	for (int i = 0; i < cmd_count; i++)
	{
		pids[i] = fork();
		if (pids[i] < 0)
		{
			perror("Fork failed");
			exit(EXIT_FAILURE);
		}

		if (pids[i] == 0) // Child process
		{
			if (i > 0)
				dup2(pipes[i - 1][0], STDIN_FILENO);
			if (i < cmd_count - 1)
				dup2(pipes[i][1], STDOUT_FILENO);

			for (int j = 0; j < cmd_count - 1; j++)
			{
				close(pipes[j][0]);
				close(pipes[j][1]);
			}

			char **cmd_args = parse_command(cmds[i]);
			execute_command(cmd_args, envp);
			ft_free_split(cmd_args); // Free allocated memory
		}
	}

	for (int i = 0; i < cmd_count - 1; i++)
	{
		close(pipes[i][0]);
		close(pipes[i][1]);
	}

	for (int i = 0; i < cmd_count; i++)
		waitpid(pids[i], NULL, 0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/07 15:23:41 by anebbou           #+#    #+#             */
/*   Updated: 2025/01/18 14:22:30 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

/**
 * validate_files - Validates that input and output files can be accessed.
 * @file1: Input file path.
 * @file2: Output file path.
 *
 * Checks if the input file can be opened for reading and the output file
 * can be created or opened for writing. Exits the program on failure.
 */
void validate_files(char *file1, char *file2)
{
	int fd = open(file1, O_RDONLY);
	if (fd < 0)
	{
		perror("Error opening input file");
		exit(EXIT_FAILURE);
	}
	close(fd);

	fd = open(file2, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd < 0)
	{
		perror("Error opening or creating output file");
		exit(EXIT_FAILURE);
	}
	close(fd);
}

/**
 * parse_command - Splits a command string into an array of arguments.
 * @cmd: Command string (e.g., "ls -l /usr/bin").
 *
 * Returns:
 *   A dynamically allocated array of strings containing the command and
 *   its arguments. Exits the program on failure.
 */
char **parse_command(char *cmd)
{
	char **split_cmd = ft_split(cmd, ' ');
	if (!split_cmd || !split_cmd[0])
	{
		ft_printf("Error: Invalid command: %s\n", cmd);
		if (split_cmd)
			ft_free_split(split_cmd);
		exit(EXIT_FAILURE);
	}
	// Debugging: Print parsed command
	ft_printf("Parsed Command: %s\n", split_cmd[0]);
	return (split_cmd);
}

/**
 * find_command_path - Finds the full path of a command.
 * @cmd: Command name.
 * @envp: Array of environment variables.
 *
 * Returns:
 *   A dynamically allocated string containing the full path of the command.
 *   Returns NULL if the command is not found.
 */
char *find_command_path(char *cmd, char **envp)
{
	char **paths = NULL;
	char *path_var = NULL;
	char *full_path = NULL;
	int i;

	// Find the PATH variable in envp
	for (i = 0; envp[i]; i++)
	{
		if (ft_strncmp(envp[i], "PATH=", 5) == 0)
		{
			path_var = envp[i] + 5; // Skip "PATH="
			break;
		}
	}
	if (!path_var)
		return (NULL);

	// Split PATH into directories
	paths = ft_split(path_var, ':');
	if (!paths)
		return (NULL);

	// Check each directory for the command
	for (i = 0; paths[i]; i++)
	{
		full_path = ft_strjoin(paths[i], "/");
		char *temp = full_path;
		full_path = ft_strjoin(full_path, cmd);
		free(temp);
		if (access(full_path, X_OK) == 0) // Check if command is executable
		{
			ft_free_split(paths);
			return (full_path);
		}
		free(full_path);
	}
	ft_free_split(paths);
	return (NULL);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirection.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anebbou <anebbou@student42.fr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 17:03:55 by anebbou           #+#    #+#             */
/*   Updated: 2025/01/18 14:13:05 by anebbou          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

/**
 * setup_redirection - Sets up file redirection for input and output.
 * @file1: Input file to read from.
 * @file2: Output file to write to.
 *
 * Opens the input and output files and redirects the standard input
 * and output to these files using dup2. Exits the program on failure.
 */
void setup_redirection(char *file1, char *file2)
{
	int fd_in = open(file1, O_RDONLY);
	if (fd_in < 0)
	{
		perror("Error opening input file");
		exit(EXIT_FAILURE);
	}

	if (dup2(fd_in, STDIN_FILENO) < 0)
	{
		perror("Error redirecting input");
		close(fd_in);
		exit(EXIT_FAILURE);
	}
	close(fd_in);

	int fd_out = open(file2, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd_out < 0)
	{
		perror("Error opening output file");
		exit(EXIT_FAILURE);
	}

	if (dup2(fd_out, STDOUT_FILENO) < 0)
	{
		perror("Error redirecting output");
		close(fd_out);
		exit(EXIT_FAILURE);
	}
	close(fd_out);
}